/*

Sapporo 2 device kernels

Version 1.0
CUDA DoubleSingle kernels

*/

#include <stdio.h>

#include "include/defines.h"

typedef float2 DS;  // double single;

struct DS4 {
  DS x, y, z, w;
};
struct DS2 {
  DS x, y;
};

__device__ DS to_DS(double a) {
  DS b;
  b.x = (float)a;
  b.y = (float)(a - b.x);
  return b;
}

__device__ double to_double(DS a) {
  double b;
  b = (double)((double)a.x + (double)a.y);
  return b;
}


// This function computes c = a + b.
__device__ DS dsadd(DS a, DS b) {
  // Compute dsa + dsb using Knuth's trick.
  float t1 = a.x + b.x;
  float e = t1 - a.x;
  float t2 = ((b.x - e) + (a.x - (t1 - e))) + a.y + b.y;
  
  // The result is t1 + t2, after normalization.
  DS c;
  c.x = e = t1 + t2;
  c.y = t2 - (e - t1);
  return c;
} // dsadd

// This function computes c = a + b.
__device__ DS dsadd(DS a, float b) {
  // Compute dsa + dsb using Knuth's trick.
  float t1 = a.x + b;
  float e = t1 - a.x;
  float t2 = ((b - e) + (a.x - (t1 - e))) + a.y;
  
  // The result is t1 + t2, after normalization.
  DS c;
  c.x = e = t1 + t2;
  c.y = t2 - (e - t1);
  return c;
} // dsadd


__device__ void body_body_interaction(double &ds_min,
                                      int &n_ngb,
                                      int *ngb_list,
                                      double4 &acc_i, 
                                      double3 &jrk_i,
                                      double4 pos_i, 
                                      double4 vel_i,
                                      double4 pos_j, 
                                      double3 vel_j,
                                      int pjID, int piID,
                                      double &EPS2) {

  double3 dr = {pos_j.x - pos_i.x, pos_j.y - pos_i.y, pos_j.z - pos_i.z};
  double ds2 = ((dr.x*dr.x + (dr.y*dr.y)) + dr.z*dr.z);
  bool ngb = true;

  if (ngb) {
    if (ds2 <= pos_i.w) {
      if (n_ngb < NGB_PB) {
        if(pjID != piID)  
          ngb_list[n_ngb++] = pjID;
      }
    }

    if (ds2 < ds_min*(pjID != piID)) {
      ds_min  = ds2;
      ngb_list[NGB_PB] = pjID;
    }    
  }

  double inv_ds  = rsqrt(ds2 + EPS2) * (pjID != piID);
  //   float inv_ds  = rsqrt(ds2 + EPS2) * (__float_as_int(pos_i.w.y) != __float_as_int(pos_j.w.y));
  //   float inv_ds  = rsqrt(ds2 + EPS2) * (pos_i.w.y != pos_j.w.y);3


  //TODO make sure the above trick still works on Fermi devices 
  //and especially for double precision calculations
  // if((ds2 + EPS2) == 0)
  //   inv_ds = 0;


  double mass    = pos_j.w;
  double inv_ds2 = inv_ds*inv_ds;                         // 1 FLOP
  double inv_ds3 = mass * inv_ds*inv_ds2;                 // 2 FLOP
  
  // 3*4 + 3 = 15 FLOP
  acc_i.x = ((inv_ds3 * dr.x) + acc_i.x);
  acc_i.y = ((inv_ds3 * dr.y) + acc_i.y);
  acc_i.z = ((inv_ds3 * dr.z) + acc_i.z);
  
  acc_i.w = (mass * inv_ds  + acc_i.w);

  double3 dv;    // 3 FLOP
  dv.x = vel_j.x - vel_i.x;
  dv.y = vel_j.y - vel_i.y;
  dv.z = vel_j.z - vel_i.z;

  double drdv = -3.0f * (inv_ds3*inv_ds2) * (((dr.x*dv.x) + dr.y*dv.y) + dr.z*dv.z);

  jrk_i.x = (jrk_i.x + inv_ds3 * dv.x) + drdv * dr.x;
  jrk_i.y = (jrk_i.y + inv_ds3 * dv.y) + drdv * dr.y;
  jrk_i.z = (jrk_i.z + inv_ds3 * dv.z) + drdv * dr.z;

  // TOTAL 50 FLOP (or 60 FLOP if compared against GRAPE6)  
}


/*
 *  blockDim.x = ni
 *  gridDim.x  = 16, 32, 64, 128, etc. 
 */ 


//TODO should make this depending on if we use Fermi or GT80/GT200
//#define ajc(i, j) (i + __mul24(blockDim.x,j))
#define ajc(i, j) (i + blockDim.x*j)
extern "C" __global__ void dev_evaluate_gravity(
                                     int        nj_total, 
                                     int        nj,
                                     int        offset,
                                     double4    *pos_j, 
                                     double4    *pos_i,
                                     double4    *acc_i,
                                     double     EPS2_d,
                                     double4    *vel_j,
                                     int        *id_j,
                                     double4    *vel_i, 
                                     double4    *jrk_i,
                                     int        *id_i,
                                     int        *ngb_list) {

  //shared_mem_size = NBLOCKS*(2*sizeof(double4) + 2*sizeof(int) + sizeof(double));   
//   __shared__ char shared_mem[NTHREADS*(sizeof(double4) + sizeof(double4) + sizeof(int)*2 + sizeof(double))];
  __shared__ char shared_mem[NTHREADS*(sizeof(double4) + sizeof(double3) + sizeof(int))];

  double4 *shared_pos = (double4*)&shared_mem[0];
  double3 *shared_vel = (double3*)&shared_pos[blockDim.x*blockDim.y];
  int     *shared_id  = (int*)&shared_vel[blockDim.x*blockDim.y];

  int local_ngb_list[NGB_PB + 1];
  int n_ngb   = 0;

  double EPS2 = EPS2_d;

  double4 pos = pos_i[threadIdx.x];

  //Combine the particle id into the w part of the position
  int particleID = id_i[threadIdx.x];

  double4 vel = (double4){vel_i[threadIdx.x].x, vel_i[threadIdx.x].y, vel_i[threadIdx.x].z, vel_i[threadIdx.x].w};

  #define LARGEnum 1e10f
  double ds_min = LARGEnum;
  
  double4 acc = {0.0f, 0.0f, 0.0f, 0.0f};
  double3 jrk = {0.0f, 0.0f, 0.0f};

  int i = blockIdx.x * (nj*blockDim.y) + nj*threadIdx.y;
  int tile = 0;
  while (i <  blockIdx.x * (nj*blockDim.y) + nj*threadIdx.y + nj) { 
    if (i + threadIdx.x < nj_total) {
      shared_pos[ajc(threadIdx.x, threadIdx.y)] = (pos_j[i + threadIdx.x]);      
      shared_id[ajc(threadIdx.x, threadIdx.y)]  = (id_j[i + threadIdx.x]); 

      shared_vel[ajc(threadIdx.x, threadIdx.y)] =  (double3){
                                                    vel_j[i + threadIdx.x].x, 
                                                    vel_j[i + threadIdx.x].y,
                                                    vel_j[i + threadIdx.x].z};

    } else {
      shared_pos[ajc(threadIdx.x, threadIdx.y)] = (double4){LARGEnum,LARGEnum,LARGEnum,0};

      shared_id[ajc(threadIdx.x, threadIdx.y)] = -1; 
      shared_vel[ajc(threadIdx.x, threadIdx.y)]   = (double3){0.0, 0.0, 0.0};
    }
    __syncthreads();
    
    int j  = min(nj - tile*blockDim.x, blockDim.x);
    int j1 = (j/16)*16;

    #pragma unroll 16
    for (int k = 0; k < j1; k++) {
          body_body_interaction(ds_min, n_ngb, local_ngb_list,
                                    acc, jrk, pos, vel,
                                    shared_pos[ajc(k, threadIdx.y)], shared_vel[ajc(k, threadIdx.y)], shared_id[ajc(k, threadIdx.y)], particleID, EPS2);
        }
        
        for (int k = j1; k < j; k++) {
          body_body_interaction(ds_min, n_ngb, local_ngb_list,
                                    acc, jrk, pos, vel,
                                    shared_pos[ajc(k, threadIdx.y)], shared_vel[ajc(k, threadIdx.y)], shared_id[ajc(k, threadIdx.y)], particleID,  EPS2);
        }
  
    __syncthreads();

    i += blockDim.x;
    tile++;
  }

  double4 *shared_jrk = (double4*)&shared_pos[0]; 
  double  *shared_ds  = (double* )&shared_jrk[blockDim.x*blockDim.y];

  double4 jerkNew = (double4){jrk.x, jrk.y, jrk.z, __int_as_float(local_ngb_list[NGB_PB])};
  
  shared_jrk[ajc(threadIdx.x, threadIdx.y)] = jerkNew;
  shared_ds [ajc(threadIdx.x, threadIdx.y)] = ds_min;
  __syncthreads();


 if (threadIdx.y == 0) {
    for (int i = 1; i < blockDim.y; i++) {
      double4 jrk1 = shared_jrk[ajc(threadIdx.x, i)];
      double  ds1  = shared_ds [ajc(threadIdx.x, i)];
 
      jerkNew.x += jrk1.x;
      jerkNew.y += jrk1.y;
      jerkNew.z += jrk1.z;
      
      if (ds1  < ds_min) {
        jerkNew.w   = jrk1.w;
        ds_min  = ds1;
      }
    }
  }
  __syncthreads();

  double4 *shared_acc = (double4*)&shared_pos[0];  
  int    *shared_ngb  = (int*   )&shared_acc[blockDim.x*blockDim.y];
  int    *shared_ofs  = (int*   )&shared_ngb[blockDim.x*blockDim.y];  
  acc.w = -acc.w;

  shared_acc[ajc(threadIdx.x, threadIdx.y)] = acc;
  shared_ngb[ajc(threadIdx.x, threadIdx.y)] = n_ngb;
  shared_ofs[ajc(threadIdx.x, threadIdx.y)] = 0;
  __syncthreads();

 if (threadIdx.y == 0) {
    for (int i = 1; i < blockDim.y; i++) {
      double4 acc1 = shared_acc[ajc(threadIdx.x, i)];
     
      acc.x += acc1.x;
      acc.y += acc1.y;
      acc.z += acc1.z;
      acc.w += acc1.w;
     
      shared_ofs[ajc(threadIdx.x, i)] = min(n_ngb + 1, NGB_PB);
      n_ngb += shared_ngb[ajc(threadIdx.x, i)];
    }
    n_ngb  = min(n_ngb, NGB_PB);
  }
  __syncthreads();

  
  if (threadIdx.y == 0) {
    //Convert results to double and write
    vel_i[offset  + blockIdx.x * blockDim.x + threadIdx.x].w = ds_min;
    acc_i[blockIdx.x * blockDim.x + threadIdx.x] = (double4){acc.x, acc.y, acc.z, acc.w};
    jrk_i[blockIdx.x * blockDim.x + threadIdx.x] = jerkNew;
  }
 

  offset  = threadIdx.x * NBLOCKS*NGB_PB + blockIdx.x * NGB_PB;
  offset += shared_ofs[ajc(threadIdx.x, threadIdx.y)];

 
  if (threadIdx.y == 0)
    ngb_list[offset++] = n_ngb;
  
  n_ngb = shared_ngb[ajc(threadIdx.x, threadIdx.y)];
  for (int i = 0; i < n_ngb; i++) 
    ngb_list[offset + i] = local_ngb_list[i];

}



/*
 *  blockDim.x = #of block in previous kernel
 *  gridDim.x  = ni

Double precision version
 */ 
extern "C" __global__ void dev_reduce_forces(double4 *acc_i, 
                                             double4 *jrk_i,
                                             double  *ds_i,
                                             double4 *vel_i,
                                             int     offset_ds,
                                             int     offset,
                                             int     *ngb_list) {
  
//   extern __shared__ double4 shared_acc[];
//    __shared__ char shared_mem[NBLOCKS*(2*sizeof(double4) + 2*sizeof(int) + sizeof(double))];
//   double4* shared_acc = (double4*)&shared_mem[0];
// 
// 
//   double4 *shared_jrk = (double4*)&shared_acc[blockDim.x];
//   int    *shared_ngb = (int*   )&shared_jrk[blockDim.x];
//   int    *shared_ofs = (int*   )&shared_ngb[blockDim.x];
//   double *shared_ds  = (double* )&shared_ofs[blockDim.x];


  __shared__ double4     shared_acc[NBLOCKS];
  __shared__ double4     shared_jrk[NBLOCKS];
  __shared__ int         shared_ngb[NBLOCKS];
  __shared__ int         shared_ofs[NBLOCKS];
  __shared__ double      shared_ds[NBLOCKS];

  
  int index = threadIdx.x * gridDim.x + blockIdx.x;

//   shared_acc[threadIdx.x] = acc_i[index];
//   shared_jrk[threadIdx.x] = jrk_i[index];
//   shared_ds [threadIdx.x] = vel_i[offset_ds + index].w;

  //Convert the data to floats
  shared_acc[threadIdx.x] = (double4){acc_i[index].x, acc_i[index].y, acc_i[index].z, acc_i[index].w};
  shared_jrk[threadIdx.x] = (double4){jrk_i[index].x, jrk_i[index].y, jrk_i[index].z, jrk_i[index].w};
  shared_ds [threadIdx.x] = (double)vel_i[offset_ds + index].w;  //TODO JB dont we miss the value at vel_i[0 + x] this way?


  int ngb_index = threadIdx.x * NGB_PB + blockIdx.x * NGB_PB*NBLOCKS;
  shared_ngb[threadIdx.x] = ngb_list[ngb_index];
  shared_ofs[threadIdx.x] = 0;
         
  __syncthreads();

  int n_ngb = shared_ngb[threadIdx.x];
  if (threadIdx.x == 0) {
    double4 acc0 = shared_acc[0];
    double4 jrk0 = shared_jrk[0];
    double  ds0 = shared_ds [0];

    for (int i = 1; i < blockDim.x; i++) {
      acc0.x += shared_acc[i].x;
      acc0.y += shared_acc[i].y;
      acc0.z += shared_acc[i].z;
      acc0.w += shared_acc[i].w;

      jrk0.x += shared_jrk[i].x;
      jrk0.y += shared_jrk[i].y;
      jrk0.z += shared_jrk[i].z;

      if (shared_ds[i] < ds0) {
        ds0    = shared_ds[i];
        jrk0.w = shared_jrk[i].w;
      }

      shared_ofs[i] = min(n_ngb + 1, NGB_PP);
      n_ngb += shared_ngb[i];
    }
    n_ngb = min(n_ngb, NGB_PP);

    jrk0.w = (int)__float_as_int(jrk0.w);


    //Store the results
    acc_i[blockIdx.x] = (double4){acc0.x, acc0.y, acc0.z, acc0.w};
    jrk_i[blockIdx.x] = (double4){jrk0.x, jrk0.y, jrk0.z, jrk0.w};;
    ds_i [blockIdx.x] = ds0;
  }
  __syncthreads();


  offset += blockIdx.x * NGB_PP + shared_ofs[threadIdx.x];
  int offset_end;
  if (threadIdx.x == 0) {
    shared_ofs[0] = offset + NGB_PP;
    ngb_list[offset++] = n_ngb;
  }
  __syncthreads();
  
  offset_end = shared_ofs[0];
  
  n_ngb = shared_ngb[threadIdx.x];
  for (int i = 0; i < n_ngb; i++)
    if (offset + i < offset_end)
      ngb_list[offset + i] = ngb_list[ngb_index + 1 + i];

  
}


/*
 * Function that moves the (changed) j-particles
 * to the correct address location.
*/
extern "C" __global__ void dev_copy_particles(int nj, int nj_max,
                                              double4   *pos_j, 
                                              double4   *pos_j_temp,
                                              int       *address_j,
                                              double2   *t_j,
                                              double4   *Ppos_j, 
                                              double4   *Pvel_j,                                              
                                              double4   *vel_j,
                                              double4   *acc_j,
                                              double4   *jrk_j,
                                              int       *id_j,
                                              double2   *t_j_temp,                                              
                                              double4   *vel_j_temp,
                                              double4   *acc_j_temp,
                                              double4   *jrk_j_temp,
                                              int       *id_j_temp) {
  int index = blockIdx.x * blockDim.x + threadIdx.x;
  //Copy the changed particles
  if (index < nj)
  {
    t_j  [address_j[index]] = t_j_temp[index];

    Ppos_j[address_j[index]] = pos_j_temp[index];
     pos_j[address_j[index]] = pos_j_temp[index];

    Pvel_j[address_j[index]] = vel_j_temp[index];
     vel_j[address_j[index]] = vel_j_temp[ index];

    acc_j[address_j[index]]  = acc_j_temp[index];
    jrk_j[address_j[index]]  = jrk_j_temp[index];

    id_j[address_j[index]]   = id_j_temp[index];
  }
}

/*

Function to predict the particles
Double Precision version

TODO timestep info

*/
extern "C" __global__ void dev_predictor(int nj,
                              double  t_i_d,
                              double2 *t_j,
                              double4 *Ppos_j,
                              double4 *Pvel_j,
                              double4 *pos_j, 
                              double4 *vel_j,
                              double4 *acc_j,
                              double4 *jrk_j) {
  int index = blockIdx.x * blockDim.x + threadIdx.x;
  
  if (index < nj) {

    //Convert the doubles to DS
    DS2 t;
    t.x = to_DS(t_j[index].x);
    t.y = to_DS(t_j[index].y);

    DS t_i;
    t_i = to_DS(t_i_d);

    double4  pos;
//     pos.x = to_DS(pos_j[index].x); pos.y = to_DS(pos_j[index].y);
//     pos.z = to_DS(pos_j[index].z); pos.w = to_DS(pos_j[index].w);
    pos = pos_j[index];
  
    double4 vel = (double4){vel_j[index].x, vel_j[index].y, vel_j[index].z, vel_j[index].w};
    double4 acc = (double4){acc_j[index].x, acc_j[index].y, acc_j[index].z, acc_j[index].w};
    double4 jrk = (double4){jrk_j[index].x, jrk_j[index].y, jrk_j[index].z, jrk_j[index].w};
  
    double dt = (t_i.x - t.x.x) + (t_i.y - t.x.y);
    double dt2 = dt*dt/2.0f;
    double dt3 = dt2*dt/3.0f;
    
    pos.x  += vel.x * dt + acc.x * dt2 + jrk.x * dt3;
    pos.y  += vel.y * dt + acc.y * dt2 + jrk.y * dt3;
    pos.z  += vel.z * dt + acc.z * dt2 + jrk.z * dt3;

    vel.x += acc.x * dt + jrk.x * dt2;
    vel.y += acc.y * dt + jrk.y * dt2;
    vel.z += acc.z * dt + jrk.z * dt2;


    Ppos_j[index] = pos;
//     Ppos_j[index].x = to_double(pos.x); Ppos_j[index].y = to_double(pos.y);
//     Ppos_j[index].z = to_double(pos.z); Ppos_j[index].w = to_double(pos.w);            

    Pvel_j[index] = (double4){vel.x, vel.y, vel.z, vel.w};
  }
  __syncthreads();
}

